# L20n For Games

## Index

1. [Version 2](#version-2): summary about L20n and this version
2. [Specification Explained](#specification-explained): l20n TFL (EBNF) grammar explained in English
3. [Standard Builtins](#standard-builtins): lists builtins that ship with l20n libraries
4. [CSV Support](#csv-support): L20n4Games libraries also support CSV files as explained in this chapter

## Version 2

Mozilla started pushing L20n (for the web) once again. With it, they have a new (in flux) language. One that's simpler than ever and easier to use.
In fact one could at it simplest see it as a good-old-fashioned key-value document, as many games tend to use.

In this version I also to keep the L20n For Games spec, as a subset of the latest possible L20n specification.
You can find the specification now as [a EBNF grammer file](https://github.com/GlenDC/l20n-mozilla-spec/blob/master/grammar.ebnf).
That is to say that it should always be possible to parse and use a pure l20n file, as anything different is added, rather than removed.

[Extended Backus-Naur Form](https://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_form) (ENBF) is a notation used to express a context-free gammer,
a type of grammar used to describe formal languages, such as a computer language.

This version is for now the default version, but can also be explicitly specified in your manifest file as `l20n`.

## Specification explained

What follows is a broader explanation to accompany the linked ENBF grammar file. Inspired by [http://l20n.org/learn](http://l20n.org/learn).

The **Body** is the root container, and contains **entries**, one per line. An entry can be:

+ a **Comment**, metadata and info for/by localizers;
+ a **Section**, acting as a header, giving structure to bigger files;
+ a **Message**, such as `hello = Hello, World!`, containing a translation linked to an **identifier**;

Most **Messages** will simply define a string (text). By default it starts right after the `=` character (**unquoted-text**),
in such cases leading and trailing whitespace characters get ignored. In the rare cases that such characters are important,
the localizer can place the text in-between quotes (**quoted-text**), as in `hello = "  hello,  world ! "`.
Text can also be spread across multiple lines (**block-text**), using the pipe character `|`, as can be seen in following example:

```
hello =
  | Hello, world!
  | Somebody here?!
```

Block text is _always_ unquoted.

A pure text element is the simplest pattern there exists, which can be either quoted (**quoted-pattern**) or unquoted (**unquoted-pattern**). A quoted pattern can be empty, an unquoted pattern has to contain content. Besides text a patter can also contain/be a **placeable**.

A **placeable** is a list of one or more **placeable-expressions** in-between curly brackets (`{`, `}`) (**placeable-list**).
A **placeable-expression** can be either a **select-expression** or in most cases, one of many possible **expressions**.
The most obvious example of an **expression** is an (external) **variable** given by the callee of the localization call:

```
// Variable info given by callee:
{
  "user": "Jane",
  "emailCount": 5
}

// As defined in L20n by the Localizer:
unreadEmails = { $user } has { $emailCount } unread emails.
```

In some rare cases the data provided by the developer will require some additional formatting.
In those cases the localizer can use a **builtin** as a **call-expression**, which is another example of an **expression**.
By default, L20n can guess which formatter to run on each kind of argument - `DATE`, `NUMBER`, `LIST` etc., but you can also call the builtin explicitly:

```
// Variable info given by callee:
{
  "lastChecked": "2016-04-22T08:13:56.354Z",
  "unreadEmails": 5
}

// As defined in L20n by the Localizer:
emails2 = You have { NUMBER($unreadEmails) } unread emails.
last-notice = Last checked: { DATETIME($lastChecked, day = "numeric", month = "long") }.
```

As you can see a **call-expression** exists out of a **builtin** before the `->`
and an **arg-list** in-between brackets (`(`, `)`) after it.
And **arg-list** consists out of one or multiple **arguments** separated by a `,` character.

An argument can also have a default value specified, in which case it is a **keyword-argument**,
rather than an **expression**. The example above shows both an example of an **expression** as **argument**,
and a **keyword-argument** as **argument**.

Custom **builtins** (formatters and other utility functions), can also be defined by the developers using the _L20n_ library,
and can be used by localizers the same way as they use the standard builtins.

Another typical example of an expression is an **identifier**,
used to reference another message within the current localization context (current or default language):

```
brandName = Loki
installing = Installing { brandName }
```

**select-expressions** are used to choose a variant based on a given selector,
by default when a number is used as a selector, L20n implicitly uses the `PLURAL` formatter (for English this is `one` or `other`):

```
// Variable info given by callee:
{
  "unreadEmails": 5
}

// As defined in L20n by the Localizer:
emails = { $unreadEmails ->
  [one] You have one unread email.
  [other] You have { $unreadEmails } unread emails.
}
```

A **select-expression** consists out of the selector (an **expression**) before the arrow `->`,
and a **member-list** after the arrow. A member-list consists out of one or multiple **members**, each on its own line.

Each **member** defines a different _variant_ and consists out of a **member-key** and a **pattern** as its value.
The key can be either a **number**, a **keyword** or the combination of an **identifier** and a **keyword**, separated by a `/` character.

A **builtin** can also be a utility function, which for example allows for more advanced selectors:

```
// Variable info given by callee:
{
  "users": ["John", "Mary"],
  "unreadEmails": 0
}

// As defined in L20n by the Localizer:
available-users = { LEN($users) ->
  [0] No users
  [1] One user.
  [2] Two users.
 *[other] { LEN($users) } users.
}
```

Additionally this example defines a default variant (**member**), by prefixing it with a `*` character.

**member-expressions** can be used to explicitly select a variant from the referenced message.
This is only possible if that message does indeed define variants. If it defines variants, and a **identifier** is used instead
of a **member-expression**, the _default_ variant will be selected. Following example showcases a use case of a **member-expression**:

```
brandName =
 *[nominative] Aurora
  [genitive] Aurore
  [dative] Aurori
  [accusative] Auroro
  [locative] Aurori
  [instrumental] Auroro

about-old = O brskalniku { brandName }
about = O { brandName[locative] }
```

**member-lists** can also be used to add additional information to a **message**,
in that case the **message** has the following structure: `<identifier>__'='__<pattern><member-list>`.
The following example showcases a use case of that:

```
brandName = Firefox
  [gender] masculine

opened-new-window = { brandName[gender] ->
 *[masculine] { brandName } otworzyl nowe okno.
  [feminine] { brandName } otworzyla nowe okno.
}
```

For web development this is also used to link automatic to HTML Attributes,
for game libraries it has no built-in use case. Game engine packages can provide support for this though.
Examples could be UI Widgets which have multiple buttons and some messages, all structured under the same message as follows:

```
login-input = Predefined value
  [ui/placeholder] example@email.com
  [ui/title]       Type your login email
  [ui/ok]          Login
  [ui/cancel]      Cancel
```

In general your messages will stay as simple as text linked to an identifier,
but with L20n you can go as complex as you need, as can be seen in following example:

```
// Variable info given by callee:
{
  "people": ["Anna", "Jack", "Mary", "Nick"]
}

// As defined in L20n by the Localizer:
liked-photo = { LEN($people) ->
    [1]     { $people } likes
    [2]     { $people } like
    [3]     { TAKE(2, $people), "one more person" } like

   *[other] { TAKE(2, $people),
              "{ LEN(DROP(2, $people)) ->
                  [1]    one more person like
                 *[other]  { LEN(DROP(2, $people)) } more people like
               }"
            }
} your photo.
```

## Standard Builtins

+ Formatters:
    + `PLURALS(n)`: number -> keyword (default when number is used as a **selector**);
    + `LIST(l)`: array -> text (using `, ` to join the list members);
    + `NUMBER(n)`: number -> string (default when number is used as part of a text);
    + `DATETIME(d)`: date -> string (default when date is used as part of a text);
+ Utility functions:
    + `LEN(l)`: return length of list as a **number**;
    + `TAKE(n, l)`: take first n amount of members of the given list, drop the rest;
    + `DROP(n, l)`: drop first n amount of members of the given list, drop the rest;

More information can be found at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl

## CSV Support

Many translators and game companies still work with spreadsheet software to make translations.
CSV files are supported and will be parsed successfully when using the `.csv` extension for the localization file.

The grammar used for the CSV parser is as follows:

```
body                 ::= (entry NL)* (entry)? EOF;
entry                ::= message;
message              ::= identifier __ ',' __ pattern;

__                   ::= [ \t]*;

identifier           ::= [a-zA-Z_.?-] ([a-zA-Z0-9_.?-])*;

pattern              ::= unquoted-pattern
                      |  quoted-pattern
                      ;
unquoted-pattern     ::= (unquoted-text | placeable)+;
quoted-pattern       ::= "+ (quoted-text | placeable)* "+;

unquoted-text        ::= .+;
quoted-text          ::= ([^"] | \"')+;

placeable            ::= '{' __ expression __ '}'

expression           ::= quoted-pattern
                      |  identifier
                      |  number
                      |  variable
                      |  call-expression

variable             ::= '$' identifier;
number               ::= [0-9]+ ('.' [0-9]+)?;

call-expression      ::= builtin '(' __ arglist? __ ')';

builtin              ::= [A-Z_.?-]+;

argument             ::= expression
                      |  keyword-argument;
keyword-argument     ::= identifier __ '=' __ quoted-pattern;
```

Besides the fact that the **CSV** parser is less powerful than the **FTL** parser,
the content they both parse does look pretty similar as can be seen in following examples:

_example.ftl_:

```ftl
title = L20n demo
hello = Hello, { $name }!

description =
    | This is a demo showcasing the simple subset CSV parser for L20n,
    | allowing you to use spreadsheet software.
```

_example.csv_:

```csv
title,L20n demo
hello,"Hello, { $name }!"
,
description,"This is a demo showcasing the simple subset CSV parser for L20n, allowing you to use spreadsheet software."
```
