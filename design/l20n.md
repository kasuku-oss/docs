# L20n For Games

## Version 2

Mozilla started pushing L20n (for the web) once again. With it, they have a new (in flux) language. One that's simpler than ever and easier to use.
In fact one could at it simplest see it as a good-old-fashioned key-value document, as many games tend to use.

In this version I also  to keep the L20n For Games spec, as a subset of the latest possible L20n specification.
You can find the specification now as [a EBNF grammer file](https://github.com/GlenDC/l20n-mozilla-spec/blob/master/grammar.ebnf).
That is to say that it should always be possible to parse and use a pure l20n file, as anything different is added, rather than removed.

[Extended Backus-Naur Form](https://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_form) (ENBF) is a notation used to express a context-free gammer,
a type of grammar used to describe formal languages, such as a computer language.

This version is for now the default version, but can also be explicitly specified in your manifest file as `l20n`.

## Specification explained

What follows is a broader explanation to accompany the linked ENBF grammar file. Inspired by [http://l20n.org/learn](http://l20n.org/learn).

The **Body** is the root container, and contains **entries**, one per line. An entry can be:

+ a **Comment**, metadata and info for/by localizers;
+ a **Section**, acting as a header, giving structure to bigger files;
+ a **Message**, such as `hello = Hello, World!`, containing a translation linked to an **identifier**;

Most **Messages** will simply define a string (text). By default it starts right after the `=` character (**unquoted-text**),
in such cases leading and trailing whitespace characters get ignored. In the rare cases that such characters are important,
the localizer can place the text in-between quotes (**quoted-text**), as in `hello = "  hello,  world ! "`.
Text can also be spread across multiple lines (**block-text**), using the pipe character `|`, as can be seen in following example:

```
hello =
  | Hello, world!
  | Somebody here?!
```

Block text is _always_ unquoted.

A pure text element is the simplest pattern there exists, which can be either quoted (**quoted-pattern**) or unquoted (**unquoted-pattern**). A quoted pattern can be empty, an unquoted pattern has to contain content. Besides text a patter can also contain/be a **placeable**.

A **placeable** is a list of one or more **placeable-expressions** in-between curly brackets (`{`, `}`) (**placeable-list**).
A **placeable-expression** can be either a **select-expression** or in most cases, one of many possible **expressions**.
The most obvious example of an **expression** is an (external) **variable** given by the callee of the localization call:

```
// Variable info given by callee:
{
  "user": "Jane",
  "emailCount": 5
}

// As defined in L20n by the Localizer:
unreadEmails = { $user } has { $emailCount } unread emails.
```

In some rare cases the data provided by the developer will require some additional formatting.
In those cases the localizer can use a **builtin** as a **call-expression**, which is another example of an **expression**.
By default, L20n can guess which formatter to run on each kind of argument - `DATE`, `NUMBER`, `LIST` etc., but you can also call the builtin explicitly:

```
// Variable info given by callee:
{
  "lastChecked": "2016-04-22T08:13:56.354Z",
  "unreadEmails": 5
}

// As defined in L20n by the Localizer:
emails2 = You have { NUMBER($unreadEmails) } unread emails.
last-notice = Last checked: { DATETIME($lastChecked, day: "numeric", month: "long") }.
```

Custom **builtins**, can also be defined by the developers using the L20n library,
and can be used by localizers the same way as they use the standard builtins.

Another typical example of an expression is an **identifier**,
used to reference another message within the current localization context (current or default language):

```
brandName = Loki
installing = Installing { brandName }
```

**select-expressions** are used to choose a variant based on a given selector,
by default when a number is used as a selector, L20n implicitly uses the `PLURAL` formatter (for English this is `one` or `other`):

```
// Variable info given by callee:
{
  "unreadEmails": 5
}

// As defined in L20n by the Localizer:
emails = { $unreadEmails ->
  [one] You have one unread email.
  [other] You have { $unreadEmails } unread emails.
}
```

A **select-expression** consists out of the selector (an **expression**) before the arrow `->`,
and a **member-list** after the arrow. A member-list consists out of one or multiple **members**, each on its own line.

Each **member** defines a different _variant_ and consists out of a **member-key** and a **pattern** as its value.
The key can be either a **number**, a **keyword** or the combination of an **identifier** and a **keyword**, separated by a `/` character.

A **builtin** can also be a utility function, which for example allows for more advanced selectors:

```
// Variable info given by callee:
{
  "users": ["John", "Mary"],
  "unreadEmails": 0
}

// As defined in L20n by the Localizer:
available-users = { LEN($users) ->
  [0] No users
  [1] One user.
  [2] Two users.
 *[other] { LEN($users) } users.
}
```

Additionally this example defines a default variant (**member**), by prefixing it with a `*` character.

**member-expressions** can be used to explicitly select a variant from the referenced message.
This is only possible if that message does indeed define variants. If it defines variants, and a **identifier** is used instead
of a **member-expression**, the _default_ variant will be selected. Following example showcases a use case of a **member-expression**:

```
brandName =
 *[nominative] Aurora
  [genitive] Aurore
  [dative] Aurori
  [accusative] Auroro
  [locative] Aurori
  [instrumental] Auroro

about-old = O brskalniku { brandName }
about = O { brandName[locative] }
```

**TODO**
+ explain other content starting from chapter 9 and beyond;
+ explain: **keyword-argument**, **argument**, **arg-list**;
+ list all standard builtins;
